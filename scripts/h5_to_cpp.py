import argparse
import itertools
import os.path
import sys

import h5py
import numpy as np

# -------------------------------------------------------

numpy_to_hdf5 = {
    "i": "H5T_STD_I",
    "l": "H5T_STD_I",
    "B": "H5T_STD_B",
    "f": "H5T_IEEE_F",
    "d": "H5T_IEEE_F",
}

# -------------------------------------------------------

file_template = \
"""
//  WARNING:
//    This file was autogenerated by {filename}.
//    Do not edit by hand!

namespace {namespace}
{{

{members}

}}
"""

class_template = \
"""
struct {name}
{{
{members}
}};
"""

simple_member_template = "{typ} {name};"

enum_template = \
"""
enum {name}_t
{{
{members}
}};
"""

enum_member_template = "{name} = {val},"

compound_type_template = \
"""
template <>
H5::CompType BuildCompType<{klass}>()
{{
  H5::CompType ctype(sizeof({klass}));

{members}

  return ctype;
}}
"""

compound_type_member_template = 'ctype.insertMember("{name}", HOFFSET({klass}, {name}), {h5type});'


# -------------------------------------------------------

class Serializable:
    def __init__(self, template, template_args, member_list=(), member_join="\n", member_indent="  ", base_indent=""):
        self.template = template
        self.template_args = template_args
        self.members = member_list
        self.join_str = member_join
        self.member_indent = member_indent
        self.base_indent = base_indent

        assert all(hasattr(member, "emit") for member in member_list), "Incompatible member type in list: " + str(
            member_list)

    def emit(self, indent=""):
        member_str = self.join_str.join(
            self.base_indent + member.emit(self.member_indent) for member in self.members)

        args = self.template_args.copy()
        args["members"] = member_str

        out = self.template.format(**args)
        return "\n".join([indent + self.base_indent + line for line in out.split("\n")])


class TypeSerializer:
    def __init__(self):
        self.discovered_enums = {}
        self.cpp_types = {}
        self.comptype_builders = {}

        # whenever we need to regenerate the Serializable
        self._dirty = False
        self._serializable = None

    def type_string(self, typ, fieldname=None, which="cpp"):
        assert which in ("cpp", "h5"), "Unrecognized kind of type string: " + which

        # sys.byteorder uses these instead of '<' and '>' like numpy or 'LE' and 'BE' like hdf5
        sysorder = {
            "little": "LE",
            "big": "BE",
        }

        cpp_name = ""
        h5_name = ""

        if h5py.check_dtype(ref=typ):
            cpp_name += "hdset_reg_ref_t"
            h5_name = "H5::PredType::STD_REF_DSETREG"
        # horrible hack, but bools are always stored as ints, so we have no other way of knowing
        elif fieldname and fieldname.startswith("is_"):
            cpp_name += "bool"
            h5_name = "H5::PredType::" + self.type_string(typ, fieldname=None)
        elif h5py.check_enum_dtype(typ):
            typenames = fieldname.split("_")
            typename = "".join(t.capitalize() for t in typenames)

            # we really shouldn't have the side effect of storing the enums
            # performed inside a function that's doing something else,
            # but it's the simplest way to do it
            self.discovered_enums[typename] = Serializable(template=enum_template, template_args={"name": typename},
                                                           member_list=[Serializable(template=enum_member_template,
                                                                                     template_args=dict(
                                                                                         name="k{name}".format(
                                                                                             name="".join(k.split())),
                                                                                         val=v))
                                                                        for k, v in h5py.check_enum_dtype(typ).items()])

            h5_name = "H5::EnumType(H5::PredType::{typ})".format(typ=self.type_string(np.dtype(str(typ)), fieldname))
            # print("discovered enum:", typename, self.discovered_enums[typename])
            cpp_name += typename
        elif h5py.check_vlen_dtype(typ):
            # for variable-length items, we have to maintain a special "handle"
            base_type = self.type_string(h5py.check_vlen_dtype(typ), fieldname)
            cpp_name += "hvl_t {name}_handle;  std::vector<{base_type}>".format(name=fieldname, base_type=base_type)
            h5_name = "H5::VarLenType(H5::PredType::{typ})".format(typ=base_type)
        elif typ.ndim > 0:
            assert typ.ndim == 1, "Don't know how to handle multi-dimensional types"
            base_type = self.type_string(typ.subdtype[0], fieldname)
            cpp_name += "std::array<{type}, {len}>".format(type=base_type, len=typ.shape[0])
            h5_name = "H5::ArrayType(H5::PredType::{typ}, 1, &std::array<hsize_t, 1>{{{count}}}[0])".format(
                typ=base_type, count=typ.shape[0])
        elif typ.char in numpy_to_hdf5:
            cpp_name += numpy_to_hdf5[typ.char]
            cpp_name += str(typ.itemsize * 8)
            cpp_name += "BE" if typ.byteorder == ">" else "LE" if typ.byteorder == "<" else sysorder[sys.byteorder]
            h5_name = "H5::PredType::" + cpp_name
        else:
            raise TypeError("Don't know how to handle type: " + str(typ))

        h5_name = h5_name.replace("H5T_", "")

        return cpp_name if which == "cpp" else h5_name

    def add_dataset(self, dataset, class_name):
        cpp_members = []
        h5_members = []
        for fieldname in dataset.dtype.names:
            typ = dataset.dtype[fieldname]
            cpp_members.append(Serializable(template=simple_member_template,
                                            template_args=dict(name=fieldname,
                                                               typ=self.type_string(typ,fieldname=fieldname))))
            h5_members.append(Serializable(template=compound_type_member_template,
                                           template_args=dict(name=fieldname,
                                                              klass=class_name,
                                                              h5type=self.type_string(typ, fieldname=fieldname, which="h5"))))

        self.cpp_types[class_name] = Serializable(template=class_template, template_args=dict(name=class_name),
                                                  member_list=cpp_members)
        self.comptype_builders[class_name] = Serializable(template=compound_type_template,
                                                          template_args=dict(klass=class_name), member_list=h5_members)

    def emit(self, namespace):
        if not self._serializable or self._dirty:
            self._serializable = Serializable(template=file_template,
                                              template_args=dict(filename=os.path.basename(__file__), namespace=namespace),
                                              member_list=tuple(itertools.chain(self.discovered_enums.values(), self.cpp_types.values(),
                                                                                self.comptype_builders.values())),
                                              member_indent="  ")

        return self._serializable.emit()
